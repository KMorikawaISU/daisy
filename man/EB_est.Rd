% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eb_est.R
\name{EB_est}
\alias{EB_est}
\title{Generalized Entropy Balancing Estimator}
\usage{
EB_est(
  dat_int,
  MU_int,
  MU_ext,
  eta,
  divergence = "KL",
  r = 1,
  w_type = FALSE,
  w_fixed = NULL,
  second_covariate = NULL,
  non_regression = TRUE,
  link = "identity",
  M = 10,
  auto = FALSE,
  r_set = c(0.01, 0.1, 0.5, 1)
)
}
\arguments{
\item{dat_int}{data.frame with internal variables. Must contain \code{y_int}.}

\item{MU_int}{matrix (n x p). First column must be 1 (intercept).}

\item{MU_ext}{numeric length-p vector. First element must be 1 (intercept).}

\item{eta}{numeric scalar: external target for step-2 (e.g., mean outcome).}

\item{divergence}{character in {"KL","LW","QLS","TS"}; used when \code{auto = FALSE}.}

\item{r}{numeric; tuning for LW/QLS/TS (ignored for KL) when \code{auto = FALSE}.}

\item{w_type}{logical; if TRUE, internal regression is weighted by first-step w.}

\item{w_fixed}{kept for compatibility (unused).}

\item{second_covariate}{optional (unused here; interface compatibility).}

\item{non_regression}{kept for compatibility (unused).}

\item{link}{"identity" | "logit" | "probit" | "gamma".}

\item{M}{numeric; box bound for step-2 lambda.}

\item{auto}{logical; if TRUE, search over {KL} U {LW,QLS,TS} x r_set by Entropy2.}

\item{r_set}{numeric vector of r candidates used when \code{auto = TRUE}.}
}
\value{
Object of class \code{"daisy_eb"}. For a single run:
\itemize{
\item \code{result["est"]}: point estimate (mean of w2 * y)
\item \code{Entropy2}: step-2 entropy value
\item \code{D1}, \code{D2}: diagnostics
\item \code{model}, \code{r}: first-step spec
}
If \code{auto = TRUE}, also:
\itemize{
\item \code{best_model}: list(divergence, r)
\item \code{leaderboard}: data.frame(divergence, r, Entropy2, D1, D2)
\item \code{all_results}: list of per-candidate result lists
}
}
\description{
Two-step estimator integrating individual-level data with external summary data
via generalized entropy balancing. The second step is fixed to KL and, for
numerical compatibility with the original code, the second-step weights are
computed from the FIRST-step linear predictor (not from LMD2).
}
